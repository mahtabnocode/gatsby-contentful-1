"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.downloadContentfulAssets = downloadContentfulAssets;
var _gatsbySourceFilesystem = require("gatsby-source-filesystem");
/**
 * @name distributeWorkload
 * @param workers A list of async functions to complete
 * @param {number} count The number of task runners to use (see assetDownloadWorkers in config)
 */
async function distributeWorkload(workers, count = 50) {
  const methods = workers.slice();
  async function task() {
    while (methods.length > 0) {
      await methods.pop()();
    }
  }
  await Promise.all(new Array(count).fill(undefined).map(() => task()));
}
/**
 * @name downloadContentfulAssets
 * @description Downloads Contentful assets to the local filesystem.
 * The asset files will be downloaded and cached. Use `localFile` to link to them
 * @param gatsbyFunctions - Gatsby's internal helper functions
 */
async function downloadContentfulAssets(gatsbyFunctions, actions, assetNodes, assetDownloadWorkers) {
  const {
    createNodeId,
    cache,
    reporter,
    getNode
  } = gatsbyFunctions;
  const {
    createNode,
    touchNode,
    createNodeField
  } = actions;

  // Any ContentfulAsset nodes will be downloaded, cached and copied to public/static
  // regardless of if you use `localFile` to link an asset or not.

  const bar = reporter.createProgress(`Downloading Contentful Assets`, assetNodes.length);
  bar.start();
  await distributeWorkload(assetNodes.map(assetNode => async () => {
    let fileNodeID;
    const {
      sys: {
        id,
        locale
      },
      url
    } = assetNode;
    const remoteDataCacheKey = `contentful-asset-${id}-${locale}`;
    const cacheRemoteData = await cache.get(remoteDataCacheKey);
    if (!url) {
      reporter.warn(`The asset with id: ${id} has no url.`);
      return Promise.resolve();
    }

    // Avoid downloading the asset again if it's been cached
    // Note: Contentful Assets do not provide useful metadata
    // to compare a modified asset to a cached version?
    if (cacheRemoteData) {
      fileNodeID = cacheRemoteData.fileNodeID;
      const existingNode = getNode(cacheRemoteData.fileNodeID);
      if (existingNode) {
        touchNode(existingNode);
      }
    }

    // If we don't have cached data, download the file
    if (!fileNodeID) {
      const fileNode = await (0, _gatsbySourceFilesystem.createRemoteFileNode)({
        url,
        cache,
        createNode,
        createNodeId
      });
      if (fileNode) {
        bar.tick();
        fileNodeID = fileNode.id;
        await cache.set(remoteDataCacheKey, {
          fileNodeID
        });
      }
    }
    if (fileNodeID) {
      createNodeField({
        node: assetNode,
        name: `localFile`,
        value: fileNodeID
      });
    }
    return Promise.resolve();
  }), assetDownloadWorkers);
}