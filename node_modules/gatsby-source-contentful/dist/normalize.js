"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeTypeName = exports.makeId = exports.getLocalizedField = exports.createRefId = exports.createNodesForContentType = exports.createLinkRefId = exports.createAssetNodes = exports.buildResolvableSet = exports.buildForeignReferenceMap = exports.buildFallbackChain = exports.buildEntryList = void 0;
var _mapValues2 = _interopRequireDefault(require("lodash/mapValues"));
var _isString2 = _interopRequireDefault(require("lodash/isString"));
var _each2 = _interopRequireDefault(require("lodash/each"));
var _isUndefined2 = _interopRequireDefault(require("lodash/isUndefined"));
var _camelCase2 = _interopRequireDefault(require("lodash/camelCase"));
var _upperFirst2 = _interopRequireDefault(require("lodash/upperFirst"));
var _gatsbyCoreUtils = require("gatsby-core-utils");
var _semver = require("semver");
var _config = require("./config");
const makeTypeName = (type, typePrefix = `ContentfulContentType`) => (0, _upperFirst2.default)((0, _camelCase2.default)(`${typePrefix} ${type}`));
exports.makeTypeName = makeTypeName;
const GATSBY_VERSION_MANIFEST_V2 = `4.3.0`;
const gatsbyVersion = typeof _gatsbyCoreUtils.getGatsbyVersion === `function` && (0, _gatsbyCoreUtils.getGatsbyVersion)() || `0.0.0`;
const gatsbyVersionIsPrerelease = (0, _semver.prerelease)(gatsbyVersion);
const shouldUpgradeGatsbyVersion = (0, _semver.lt)(gatsbyVersion, GATSBY_VERSION_MANIFEST_V2) && !gatsbyVersionIsPrerelease;
const getLocalizedField = ({
  field,
  locale,
  localesFallback
}) => {
  if (!field) {
    return null;
  }
  if (!(0, _isUndefined2.default)(field[locale.code])) {
    return field[locale.code];
  } else if (!(0, _isUndefined2.default)(locale.code) && !(0, _isUndefined2.default)(localesFallback[locale.code])) {
    return getLocalizedField({
      field,
      locale: {
        ...locale,
        code: localesFallback[locale.code]
      },
      localesFallback
    });
  } else {
    return null;
  }
};
exports.getLocalizedField = getLocalizedField;
const buildFallbackChain = locales => {
  const localesFallback = {};
  (0, _each2.default)(locales, locale => localesFallback[locale.code] = locale.fallbackCode);
  return localesFallback;
};
exports.buildFallbackChain = buildFallbackChain;
const makeGetLocalizedField = ({
  locale,
  localesFallback
}) => field => getLocalizedField({
  field,
  locale,
  localesFallback
});
const makeId = ({
  spaceId,
  id,
  currentLocale,
  defaultLocale,
  type
}) => {
  const normalizedType = type.startsWith(`Deleted`) ? type.substring(`Deleted`.length) : type;
  return currentLocale === defaultLocale ? `${spaceId}___${id}___${normalizedType}` : `${spaceId}___${id}___${normalizedType}___${currentLocale}`;
};
exports.makeId = makeId;
const makeMakeId = ({
  currentLocale,
  defaultLocale,
  createNodeId
}) => (spaceId, id, type) => createNodeId(makeId({
  spaceId,
  id,
  currentLocale,
  defaultLocale,
  type
}));

// Generates an unique id per space for reference resolving
// TODO: space id is actually not factored in here!
const createRefId = node => `${node.sys.id}___${node.sys.type}`;
exports.createRefId = createRefId;
const createLinkRefId = link => `${link.sys.id}___${link.sys.linkType}`;
exports.createLinkRefId = createLinkRefId;
const buildEntryList = ({
  contentTypeItems,
  currentSyncData
}) => {
  // Create buckets for each type sys.id that we care about (we will always want an array for each, even if its empty)
  const map = new Map(contentTypeItems.map(contentType => [contentType.sys.id, []]));
  // Now fill the buckets. Ignore entries for which there exists no bucket. (This happens when filterContentType is used)
  currentSyncData.entries.map(entry => {
    const arr = map.get(entry.sys.contentType.sys.id);
    if (arr) {
      arr.push(entry);
    }
  });
  // Order is relevant, must map 1:1 to contentTypeItems array
  return contentTypeItems.map(contentType => map.get(contentType.sys.id) || []);
};
exports.buildEntryList = buildEntryList;
const buildResolvableSet = ({
  entryList,
  existingNodes = [],
  assets = []
}) => {
  const resolvable = new Set();
  existingNodes.forEach(node => {
    var _node$sys;
    if (node.internal.owner === `gatsby-source-contentful` && node !== null && node !== void 0 && (_node$sys = node.sys) !== null && _node$sys !== void 0 && _node$sys.id) {
      // We need to add only root level resolvable (assets and entries)
      // Derived nodes (markdown or JSON) will be recreated if needed.
      resolvable.add(createRefId(node));
    }
  });
  entryList.forEach(entries => {
    entries.forEach(entry => resolvable.add(createRefId(entry)));
  });
  assets.forEach(assetItem => resolvable.add(createRefId(assetItem)));
  return resolvable;
};
exports.buildResolvableSet = buildResolvableSet;
function cleanupReferencesFromEntry(foreignReferenceMapState, entry) {
  const {
    links,
    backLinks
  } = foreignReferenceMapState;
  const entryId = entry.sys.id;
  const entryLinks = links[entryId];
  if (entryLinks) {
    entryLinks.forEach(link => {
      const backLinksForLink = backLinks[link];
      if (backLinksForLink) {
        const newBackLinks = backLinksForLink.filter(({
          id
        }) => id !== entryId);
        if (newBackLinks.length > 0) {
          backLinks[link] = newBackLinks;
        } else {
          delete backLinks[link];
        }
      }
    });
  }
  delete links[entryId];
}
const buildForeignReferenceMap = ({
  contentTypeItems,
  entryList,
  resolvable,
  defaultLocale,
  space,
  useNameForId,
  previousForeignReferenceMapState,
  deletedEntries
}) => {
  const foreignReferenceMapState = previousForeignReferenceMapState || {
    links: [],
    backLinks: {}
  };
  const {
    links,
    backLinks
  } = foreignReferenceMapState;
  for (const deletedEntry of deletedEntries) {
    // remove stored entries from entry that is being deleted
    cleanupReferencesFromEntry(foreignReferenceMapState, deletedEntry);
  }
  contentTypeItems.forEach((contentTypeItem, i) => {
    // Establish identifier for content type
    //  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
    //  but sometimes a base62 uuid generated by Contentful, hence the option)
    let contentTypeItemId;
    if (useNameForId) {
      contentTypeItemId = contentTypeItem.name.toLowerCase();
    } else {
      contentTypeItemId = contentTypeItem.sys.id.toLowerCase();
    }
    entryList[i].forEach(entryItem => {
      // clear links added in previous runs for given entry, as we will recreate them anyway
      cleanupReferencesFromEntry(foreignReferenceMapState, entryItem);
      const entryItemFields = entryItem.fields;
      Object.keys(entryItemFields).forEach(entryItemFieldKey => {
        if (entryItemFields[entryItemFieldKey]) {
          var _entryItemFieldValue$;
          const entryItemFieldValue = entryItemFields[entryItemFieldKey][defaultLocale];
          // If this is an array of single reference object
          // add to the reference map, otherwise ignore.
          if (Array.isArray(entryItemFieldValue)) {
            if (entryItemFieldValue[0] && entryItemFieldValue[0].sys && entryItemFieldValue[0].sys.type && entryItemFieldValue[0].sys.id) {
              entryItemFieldValue.forEach(v => {
                const key = createLinkRefId(v);
                // Don't create link to an unresolvable field.
                if (!resolvable.has(key)) {
                  return;
                }
                if (!backLinks[key]) {
                  backLinks[key] = [];
                }
                backLinks[key].push({
                  name: contentTypeItemId,
                  id: entryItem.sys.id,
                  spaceId: space.sys.id,
                  type: entryItem.sys.type
                });
                if (!links[entryItem.sys.id]) {
                  links[entryItem.sys.id] = [];
                }
                links[entryItem.sys.id].push(key);
              });
            }
          } else if (entryItemFieldValue !== null && entryItemFieldValue !== void 0 && (_entryItemFieldValue$ = entryItemFieldValue.sys) !== null && _entryItemFieldValue$ !== void 0 && _entryItemFieldValue$.type && entryItemFieldValue.sys.id) {
            const key = createLinkRefId(entryItemFieldValue);
            // Don't create link to an unresolvable field.
            if (!resolvable.has(key)) {
              return;
            }
            if (!backLinks[key]) {
              backLinks[key] = [];
            }
            backLinks[key].push({
              name: contentTypeItemId,
              id: entryItem.sys.id,
              spaceId: space.sys.id,
              type: entryItem.sys.type
            });
            if (!links[entryItem.sys.id]) {
              links[entryItem.sys.id] = [];
            }
            links[entryItem.sys.id].push(key);
          }
        }
      });
    });
  });
  return foreignReferenceMapState;
};
exports.buildForeignReferenceMap = buildForeignReferenceMap;
function prepareTextNode(id, node, _key, text) {
  const str = (0, _isString2.default)(text) ? text : ``;
  const textNode = {
    id,
    parent: node.id,
    raw: str,
    internal: {
      type: `ContentfulText`,
      mediaType: `text/markdown`,
      content: str,
      // entryItem.sys.publishedAt is source of truth from contentful
      contentDigest: node.sys.publishedAt
    },
    children: [],
    sys: {
      type: `TextNode`
    }
  };
  return textNode;
}
let numberOfContentSyncDebugLogs = 0;
const maxContentSyncDebugLogTimes = 50;
let warnOnceForNoSupport = false;
let warnOnceToUpgradeGatsby = false;

/**
 * This fn creates node manifests which are used for Gatsby Cloud Previews via the Content Sync API/feature.
 * Content Sync routes a user from Contentful to a page created from the entry data they're interested in previewing.
 */

function contentfulCreateNodeManifest({
  pluginConfig,
  entryItem,
  entryNode,
  space,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  unstable_createNodeManifest
}) {
  const isPreview = pluginConfig.get(`host`) === `preview.contentful.com`;
  const createNodeManifestIsSupported = typeof unstable_createNodeManifest === `function`;
  const shouldCreateNodeManifest = isPreview && createNodeManifestIsSupported;
  const updatedAt = entryItem.sys.updatedAt;
  const manifestId = `${space.sys.id}-${entryItem.sys.id}-${updatedAt}`;
  if (process.env.CONTENTFUL_DEBUG_NODE_MANIFEST === `true` && numberOfContentSyncDebugLogs <= maxContentSyncDebugLogTimes) {
    numberOfContentSyncDebugLogs++;
    console.info(JSON.stringify({
      isPreview,
      createNodeManifestIsSupported,
      shouldCreateNodeManifest,
      manifestId,
      entryItemSysUpdatedAt: updatedAt
    }));
  }
  if (shouldCreateNodeManifest) {
    if (shouldUpgradeGatsbyVersion && !warnOnceToUpgradeGatsby) {
      console.warn(`Your site is doing more work than it needs to for Preview, upgrade to Gatsby ^${GATSBY_VERSION_MANIFEST_V2} for better performance`);
      warnOnceToUpgradeGatsby = true;
    }
    unstable_createNodeManifest({
      manifestId,
      node: entryNode,
      updatedAtUTC: updatedAt
    });
  } else if (isPreview && !createNodeManifestIsSupported && !warnOnceForNoSupport) {
    console.warn(`Contentful: Your version of Gatsby core doesn't support Content Sync (via the unstable_createNodeManifest action). Please upgrade to the latest version to use Content Sync in your site.`);
    warnOnceForNoSupport = true;
  }
}
const createNodesForContentType = ({
  contentTypeItem,
  entries,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  unstable_createNodeManifest,
  createNode,
  createNodeId,
  getNode,
  resolvable,
  foreignReferenceMap,
  defaultLocale,
  locales,
  space,
  useNameForId,
  pluginConfig
}) => {
  // Establish identifier for content type
  //  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
  //  but sometimes a base62 uuid generated by Contentful, hence the option)
  let contentTypeItemId;
  if (useNameForId) {
    contentTypeItemId = contentTypeItem.name;
  } else {
    contentTypeItemId = contentTypeItem.sys.id;
  }
  const createNodePromises = [];

  // Create a node for the content type
  const contentTypeNode = {
    id: createNodeId(contentTypeItemId),
    name: contentTypeItem.name,
    displayField: contentTypeItem.displayField,
    description: contentTypeItem.description,
    internal: {
      type: `ContentfulContentType`,
      contentDigest: contentTypeItem.sys.updatedAt
    },
    // https://www.contentful.com/developers/docs/references/content-delivery-api/#/introduction/common-resource-attributes
    // https://www.contentful.com/developers/docs/references/graphql/#/reference/schema-generation/sys-field
    sys: {
      type: contentTypeItem.sys.type,
      id: contentTypeItem.sys.id,
      spaceId: contentTypeItem.sys.space.sys.id,
      environmentId: contentTypeItem.sys.environment.sys.id,
      firstPublishedAt: contentTypeItem.sys.createdAt,
      publishedAt: contentTypeItem.sys.updatedAt,
      publishedVersion: contentTypeItem.sys.revision
    }
  };
  createNodePromises.push(createNode(contentTypeNode));
  locales.forEach(locale => {
    const localesFallback = buildFallbackChain(locales);
    const mId = makeMakeId({
      currentLocale: locale.code,
      defaultLocale,
      createNodeId
    });
    const getField = makeGetLocalizedField({
      locale,
      localesFallback
    });

    // Warn about any field conflicts
    const conflictFields = [];
    contentTypeItem.fields.forEach(contentTypeItemField => {
      const fieldName = contentTypeItemField.id;
      if (_config.restrictedNodeFields.includes(fieldName)) {
        console.log(`Restricted field found for ContentType ${contentTypeItemId} and field ${fieldName}. Prefixing with ${_config.conflictFieldPrefix}.`);
        conflictFields.push(fieldName);
      }
    });
    const childrenNodes = [];

    // First create nodes for each of the entries of that content type
    const entryNodes = entries.map(entryItem => {
      const entryNodeId = mId(space.sys.id, entryItem.sys.id, entryItem.sys.type);
      const existingNode = getNode(entryNodeId);
      if ((existingNode === null || existingNode === void 0 ? void 0 : existingNode.updatedAt) === entryItem.sys.updatedAt) {
        // The Contentful model has `.sys.updatedAt` leading for an entry. If the updatedAt value
        // of an entry did not change, then we can trust that none of its children were changed either.
        return null;
      }

      // Get localized fields.
      const entryItemFields = (0, _mapValues2.default)(entryItem.fields, (v, k) => {
        const fieldProps = contentTypeItem.fields.find(field => field.id === k);
        if (!fieldProps) {
          throw new Error(`Unable to translate field ${k}`);
        }
        const localizedField = fieldProps.localized ? getField(v) : v[defaultLocale];
        return localizedField;
      });

      // Prefix any conflicting fields
      // https://github.com/gatsbyjs/gatsby/pull/1084#pullrequestreview-41662888
      conflictFields.forEach(conflictField => {
        entryItemFields[`${_config.conflictFieldPrefix}${conflictField}`] = entryItemFields[conflictField];
        delete entryItemFields[conflictField];
      });

      // Add linkages to other nodes based on foreign references
      Object.keys(entryItemFields).forEach(entryItemFieldKey => {
        if (entryItemFields[entryItemFieldKey]) {
          var _entryItemFieldValue$4;
          const entryItemFieldValue = entryItemFields[entryItemFieldKey];
          if (Array.isArray(entryItemFieldValue)) {
            var _entryItemFieldValue$2, _entryItemFieldValue$3;
            if (((_entryItemFieldValue$2 = entryItemFieldValue[0]) === null || _entryItemFieldValue$2 === void 0 ? void 0 : (_entryItemFieldValue$3 = _entryItemFieldValue$2.sys) === null || _entryItemFieldValue$3 === void 0 ? void 0 : _entryItemFieldValue$3.type) === `Link`) {
              // Check if there are any values in entryItemFieldValue to prevent
              // creating an empty node field in case when original key field value
              // is empty due to links to missing entities
              const resolvableEntryItemFieldValue = entryItemFieldValue.filter(v => resolvable.has(createLinkRefId(v))).map(function (v) {
                return mId(space.sys.id, v.sys.id, v.sys.linkType || v.sys.type);
              });
              if (resolvableEntryItemFieldValue.length !== 0) {
                entryItemFields[entryItemFieldKey] = resolvableEntryItemFieldValue;
              }
            }
          } else if ((entryItemFieldValue === null || entryItemFieldValue === void 0 ? void 0 : (_entryItemFieldValue$4 = entryItemFieldValue.sys) === null || _entryItemFieldValue$4 === void 0 ? void 0 : _entryItemFieldValue$4.type) === `Link`) {
            if (resolvable.has(createLinkRefId(entryItemFieldValue))) {
              entryItemFields[entryItemFieldKey] = mId(space.sys.id, entryItemFieldValue.sys.id, entryItemFieldValue.sys.linkType || entryItemFieldValue.sys.type);
            }
          }
        }
      });

      // Add reverse linkages if there are any for this node
      const foreignReferences = foreignReferenceMap[createRefId(entryItem)];
      if (foreignReferences) {
        foreignReferences.forEach(foreignReference => {
          const existingReference = entryItemFields[foreignReference.name];
          if (existingReference) {
            // If the existing reference is a string, we're dealing with a
            // many-to-one reference which has already been recorded, so we can
            // skip it. However, if it is an array, add it:
            if (Array.isArray(existingReference)) {
              entryItemFields[foreignReference.name].push(mId(foreignReference.spaceId, foreignReference.id, foreignReference.type));
            }
          } else {
            // If there is one foreign reference, there can be many.
            // Best to be safe and put it in an array to start with.
            entryItemFields[foreignReference.name] = [mId(foreignReference.spaceId, foreignReference.id, foreignReference.type)];
          }
        });
      }

      // Create actual entry node
      let entryNode = {
        id: entryNodeId,
        parent: contentTypeItemId,
        children: [],
        internal: {
          type: makeTypeName(contentTypeItemId),
          // The content of an entry is guaranteed to be updated if and only if the .sys.updatedAt field changed
          contentDigest: entryItem.sys.updatedAt
        },
        // https://www.contentful.com/developers/docs/references/content-delivery-api/#/introduction/common-resource-attributes
        // https://www.contentful.com/developers/docs/references/graphql/#/reference/schema-generation/sys-field
        sys: {
          type: entryItem.sys.type,
          id: entryItem.sys.id,
          locale: locale.code,
          spaceId: entryItem.sys.space.sys.id,
          environmentId: entryItem.sys.environment.sys.id,
          contentType: createNodeId(contentTypeItemId),
          firstPublishedAt: entryItem.sys.createdAt,
          publishedAt: entryItem.sys.updatedAt,
          publishedVersion: entryItem.sys.revision
        },
        metadata: {
          tags: entryItem.metadata.tags.map(tag => createNodeId(`ContentfulTag__${space.sys.id}__${tag.sys.id}`))
        }
      };
      contentfulCreateNodeManifest({
        pluginConfig,
        entryItem,
        entryNode,
        space,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_createNodeManifest
      });

      // Replace text fields with text nodes so we can process their markdown
      // into HTML.
      Object.keys(entryItemFields).forEach(entryItemFieldKey => {
        // TODO:: how expensive is this?
        const field = contentTypeItem.fields.find(f => (_config.restrictedNodeFields.includes(f.id) ? `${_config.conflictFieldPrefix}${f.id}` : f.id) === entryItemFieldKey);
        if ((field === null || field === void 0 ? void 0 : field.type) === `Text`) {
          const textNodeId = createNodeId(`${entryNodeId}${entryItemFieldKey}TextNode`);

          // The Contentful model has `.sys.updatedAt` leading for an entry. If the updatedAt value
          // of an entry did not change, then we can trust that none of its children were changed either.
          // (That's why child nodes use the updatedAt of the parent node as their digest, too)
          const existingNode = getNode(textNodeId);
          if ((existingNode === null || existingNode === void 0 ? void 0 : existingNode.updatedAt) !== entryItem.sys.updatedAt) {
            const textNode = prepareTextNode(textNodeId, entryNode, entryItemFieldKey, entryItemFields[entryItemFieldKey]);
            childrenNodes.push(textNode);
          }
          entryItemFields[entryItemFieldKey] = textNodeId;
        }
      });
      entryNode = {
        ...entryItemFields,
        ...entryNode
      };
      return entryNode;
    });
    entryNodes.forEach(entryNode => {
      if (!entryNode) {
        return;
      }
      createNodePromises.push(createNode(entryNode));
    });
    childrenNodes.forEach(entryNode => {
      createNodePromises.push(createNode(entryNode));
    });
  });
  return createNodePromises;
};
exports.createNodesForContentType = createNodesForContentType;
const createAssetNodes = ({
  assetItem,
  createNode,
  createNodeId,
  defaultLocale,
  locales,
  space
}) => {
  const createNodePromises = [];
  locales.forEach(locale => {
    var _assetItem$fields, _file$details$image$w, _file$details, _file$details$image, _file$details$image$h, _file$details2, _file$details2$image, _file$details$size, _file$details3;
    const localesFallback = buildFallbackChain(locales);
    const mId = makeMakeId({
      currentLocale: locale.code,
      defaultLocale,
      createNodeId
    });
    const getField = makeGetLocalizedField({
      locale,
      localesFallback
    });
    const fileRes = getField((_assetItem$fields = assetItem.fields) === null || _assetItem$fields === void 0 ? void 0 : _assetItem$fields.file);
    if (!fileRes) {
      return;
    }
    const file = fileRes;

    // Skip empty and unprocessed assets in Preview API
    if (!file || !file.url || !file.contentType || !file.fileName) {
      return;
    }
    const assetNode = {
      id: mId(space.sys.id, assetItem.sys.id, assetItem.sys.type),
      parent: null,
      children: [],
      file,
      internal: {
        type: `ContentfulAsset`,
        // The content of an asset is guaranteed to be updated if and only if the .sys.updatedAt field changed
        contentDigest: assetItem.sys.updatedAt
      },
      // https://www.contentful.com/developers/docs/references/content-delivery-api/#/introduction/common-resource-attributes
      // https://www.contentful.com/developers/docs/references/graphql/#/reference/schema-generation/sys-field
      sys: {
        type: assetItem.sys.type,
        id: assetItem.sys.id,
        locale: locale.code,
        spaceId: assetItem.sys.space.sys.id,
        environmentId: assetItem.sys.environment.sys.id,
        firstPublishedAt: assetItem.sys.createdAt,
        publishedAt: assetItem.sys.updatedAt,
        publishedVersion: assetItem.sys.revision
      },
      placeholderUrl: `https:${file.url}?w=%width%&h=%height%`,
      url: `https:${file.url}`,
      // These fields are optional for edge cases in the Preview API and Contentfuls asset processing
      width: (_file$details$image$w = (_file$details = file.details) === null || _file$details === void 0 ? void 0 : (_file$details$image = _file$details.image) === null || _file$details$image === void 0 ? void 0 : _file$details$image.width) !== null && _file$details$image$w !== void 0 ? _file$details$image$w : null,
      height: (_file$details$image$h = (_file$details2 = file.details) === null || _file$details2 === void 0 ? void 0 : (_file$details2$image = _file$details2.image) === null || _file$details2$image === void 0 ? void 0 : _file$details2$image.height) !== null && _file$details$image$h !== void 0 ? _file$details$image$h : null,
      size: (_file$details$size = (_file$details3 = file.details) === null || _file$details3 === void 0 ? void 0 : _file$details3.size) !== null && _file$details$size !== void 0 ? _file$details$size : null,
      metadata: {
        tags: assetItem.metadata.tags.map(tag => createNodeId(`ContentfulTag__${space.sys.id}__${tag.sys.id}`))
      },
      title: assetItem.fields.title ? getField(assetItem.fields.title) : ``,
      description: assetItem.fields.description ? getField(assetItem.fields.description) : ``,
      // Satisfy the Gatsby ImageCDN feature
      mimeType: file.contentType,
      filename: file.fileName
    };

    // if the node hasn't changed, createNode may return `undefined` instead of a Promise on some versions of Gatsby
    const maybePromise = createNode(assetNode);
    createNodePromises.push(maybePromise !== null && maybePromise !== void 0 && maybePromise.then ? maybePromise.then(() => assetNode) : assetNode);
  });
  return createNodePromises;
};
exports.createAssetNodes = createAssetNodes;